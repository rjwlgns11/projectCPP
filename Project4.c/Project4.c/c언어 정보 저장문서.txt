서식문자 관련 

%d = 부호있는 10진수 정수 출력 (int,short,char) 
%ld = 부호있는 10진수 정수 출력 (long) 
%lld = 부호있는 10진수 정수 출력 (long long) 
%u = 부호없는 10진수단위 정수 출력(unsigned int) 
%x = 부호없는 16진수 정수 출력 (unsigned int) 
%f = 10진수 방식의 부동 소수점 풀력, (long) scanf함수기준 = 실수를 입력받는다 
%lf = 10진수 방식의 부동소수점 출력 (long double) 
%e, %E = e 또는 E 방식의 부동소수점 실수 출력 (float, long double) 
%g, %G = 값에 따라 %f와 %e 사이에서 선택 (float, double) 
%c = 아스키 코드값 출력 
%s = 문자열 단위 출력 (배열,문자열) 
%p = 포인터의 주소값 

산술연산자 

대입연산자(=) 오른쪽에 있는값을 왼쪽에 대입시킨다. 
덧셈 뺄셈(+,-) 
곱셈 나눗셈(*,/)
나머지값 반환 연산자(%) 왼쪽의 피연산자값을 오른쪽의 피연산자값으로 나눴을때 얻게되는 나머지를 반환한다 

복합  대입 연산자 

*= 곱한뒤 대입
/= 나눈뒤 대입
%= 나머지를 대입?
+= 더한뒤 대입
-= 뺀뒤 대입
<<=,>>= 비트열을 왼,오른쪽으로 이동시킨후 대입 
&= 비트단위 and 연산후 대입(두개의 비트가 모두 1일때 1을 반환) 
|= 비트단위 or 연산후 대입(두개의 비트중 하나라도 1일경우 1을 반환) 
^= 비트단위 xor 연산후 대입(두개의 비트가 서로 다른경우 1반환) 
비트 연산자 

& 비트단위로 and 연산을 한다(두 비트가 모두 1이어야 1반환) 
| 비트단위로 or 연산을 한다(두 비트중 하나라도 1이면 1반환) 
^ 비트단위로 xor 연산을 한다(두 비트가 다르면 1반환) 
~ 피연산자의 모든 비트를 반전시킨다 
<< 피연산자의 비트를 왼쪽으로 이동시킨다(이때의 결과값은 컴파일러마다 다름) 
>> 피연산자의 비트를 오른쪽으로 이동시킨다(이때의 결과값은 컴파일러마다 다름) 

데이터 자료형 

int = 4바이트 정수
short = 2바이트 정수 
char = 1바이트 정수(주로 문자의 저장에 이용) 
long = 4바이트 정수 
long long = 8바이트 정수 
float = 4바이트 실수 
double = 8바이트 실수 
long double = 8바이트 이상 실수 (double 이상의 표현범위) 

음수의 표현을 허용하지 않는 자료형 
unsigned " 음수의 표현을 허용하지 않는 키워드"


