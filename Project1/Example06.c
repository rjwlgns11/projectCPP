//#include "Header.h"
//
////증감 연산자
////a++ , a--  (후위 연산) 연산을 먼저 진행한 후, a를 1 증가/감소 시킵니다.
////++a , --a  (전위 연산) a를 1 증가/감소 시키고, 남은 연산을 진행
// 
////비트 연산자
////컴퓨터가 연산하는 방식과 동일한 형태의 연산 방식으로 가장 빠르게 연산 할 수 있습니다.
////원리 : 바이너리 코드(binary code)을 통해 0, 1로 결과를 판단합니다.
////0일 경우 false, 1일 경우 true
//
//
//int main()
//{
//	//증감 연산자 예시
//	int a = 1;
//	int b = ++a + 1;
//	printf("a = %d\n", a);
//	printf("b = %d\n", b);
//
//	a = 1; //a의 값을 1로 초기화합니다.(변수를 만들고 난 다음부터는 변수의 이름 = 값으로 변경)
//	b = a++ + 1;
//	printf("a = %d\n", a);
//	printf("b = %d\n", b);
//
//	
//	int number1 = 15; // 00000000 00000000 00000000 00001111
//	int number2 = 20; // 00000000 00000000 00000000 00010100
//
//	//1) 비트 & 연산(AND 연산)
//	printf("%d\n", number1 & number2); // 4
//
//	// 값이 있는 부분에서 같은 위치에 1인 값만 1로 적용합니다.
//	// 00001111
//	// 00010100
//	// 00000100
//	// 해당 값을 십진수로 변경합니다.
//
//	//2의 0제곱부터 순서대로 값이 증가합니다.
//	//모든 수의 0제곱은 1입니다.
//	//1 2 4 8 16 32 64 128 256 512 1024....
//
//	//2) 비트 | 연산
//	//값이 있는 부분에서 하나라도 1이 있으면 전부 1로 적용합니다.
//	printf("%d\n", number1 | number2);
//
//
//	//3) 비트 ^ 연산 (XOR) :Exclusive or 배타적 논리합
//	//값이 있는 부분이 서로 다를 경우 1로 적용합니다.
//
//	printf("%d\n", number1 ^ number2);
//
//	//4) 비트 ~ 연산 (NOT) : 보수 연산
//	//양수일 경우 양수를 음수로 바꾸고 -1하면 보수 값이 나옴.
//	//음수일 경우 양수로 바꾸고 +1 하면 보수 값이 나옴.
//	printf("%d\n", ~number1); // -16
//
//	int number3 = -16;
//	printf("%d\n", ~number3);
//
//	return 0;
//}